<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Allen&#39;s Blog</title>
    <link>http://dmdgeeker.com/post/</link>
    <description>Recent content in Posts on Allen&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <managingEditor>xheavey@gmail.com (Allen Heavey)</managingEditor>
    <webMaster>xheavey@gmail.com (Allen Heavey)</webMaster>
    <copyright>(c) 2016 Allen Heavey.</copyright>
    <lastBuildDate>Sat, 24 Sep 2016 14:36:06 +0800</lastBuildDate>
    <atom:link href="http://dmdgeeker.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Markdown 语法</title>
      <link>http://dmdgeeker.com/2016/09/24/markdown-%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sat, 24 Sep 2016 14:36:06 +0800</pubDate>
      <author>xheavey@gmail.com (Allen Heavey)</author>
      <guid>http://dmdgeeker.com/2016/09/24/markdown-%E8%AF%AD%E6%B3%95/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://daringfireball.net/projects/markdown/&#34;&gt;Markdown&lt;/a&gt; 在用于写简单文本非常方便。在这里将给出一些示例来示范Markdown所支持的标记语法。&lt;br /&gt;
这里并没有介绍所有Markdown文档，如果你需要完整版来进行深入了解，请查看&lt;a href=&#34;http://daringfireball.net/projects/markdown/&#34;&gt;Markdown&lt;/a&gt;这个网站。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#强调&#34;&gt;强调&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#删除&#34;&gt;删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#代码&#34;&gt;代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#链接&#34;&gt;链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#图像&#34;&gt;图像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#标题&#34;&gt;标题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#段落&#34;&gt;段落&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#引用&#34;&gt;引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#列表&#34;&gt;列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#表格&#34;&gt;表格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#代码高亮&#34;&gt;代码高亮&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#水平分隔线&#34;&gt;水平分隔线&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;强调&#34;&gt;强调&lt;/h2&gt;

&lt;p&gt;Markdown 通过 * (星号) 和 _ (下划线) 来作为着重表示的标记。
如下所示：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;单个星号&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;单个下划线&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;两个星号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;两个下划线&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;示例代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*单个星号*

_单个下划线_

**两个星号**

__两个下划线__
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你必须使用相同的标记来开关标记块。&lt;/p&gt;

&lt;p&gt;某些情况下，强调可以只是放置于词中间(如he*ll*o), 如Github等。但也有一些不会渲染出效果，如本博客所示。&lt;br /&gt;
但是如果在 * 和 _ 两边加上空格，那它会以普通文本形式进行渲染。
如果有需要, 你也可以在星号和下划线前加入反斜线进行转译。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\*这段文本在普通星号之间\*
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;删除&#34;&gt;删除&lt;/h2&gt;

&lt;p&gt;删除标记使用的是&lt;code&gt;~~&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;del&gt;这是待删除的文本&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;原代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~~这是待删除的文本~~
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;`&lt;/code&gt;(反引号)来表示行内代码，与格式化代码块不同，行内代码表示其在一行中，如：&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;printf()&lt;/code&gt; 函数。&lt;/p&gt;

&lt;p&gt;示例代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;使用 `printf()` 函数。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想在代码中使用反引号，可以使用多个反引号作为开闭标记。&lt;br /&gt;
&lt;code&gt;这是一个普通的(`)反引号.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;``这是一个普通的(`)反引号.``
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;

&lt;p&gt;Markdown支持内联和引用链接，这两种方式的链接名都放在方括号(&lt;code&gt;[]&lt;/code&gt;)中。&lt;/p&gt;

&lt;p&gt;创建一个链接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[链接名](链接地址)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个Github链接&lt;a href=&#34;https://github.com&#34; title=&#34;可选的链接标题&#34;&gt;Github&lt;/a&gt;如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Github](https://github.com &amp;quot;可选的链接标题&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用链接第二部份也是使用方括号，里面放置一个引用链接的标签。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是一个[示例][example]引用链接。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下:&lt;br /&gt;
这是一个&lt;a href=&#34;http://example.com/&#34; title=&#34;可选标题&#34;&gt;示例&lt;/a&gt;引用链接。&lt;/p&gt;

&lt;p&gt;在文档的其它地方（通常是文尾）放置一个标签定义:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[example]: http://example.com/  &amp;quot;可选的标题&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链接这一部份还有很多细节，具体详情可以参见&lt;a href=&#34;http://daringfireball.net/projects/markdown/syntax#link&#34;&gt;链接说明&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;图像&#34;&gt;图像&lt;/h2&gt;

&lt;p&gt;在Markdown里引用一张图片与一个链接非常类似，也如链接一样有两种方式。其它链接不同的是，在语法前加了一个&lt;code&gt;!&lt;/code&gt;（感叹号)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.addictedtoibiza.com/wp-content/uploads/2012/12/example.png&#34; alt=&#34;Alt text&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![Alt text](http://www.addictedtoibiza.com/wp-content/uploads/2012/12/example.png)

![Alt text](http://www.addictedtoibiza.com/wp-content/uploads/2012/12/example.png &amp;quot;可选的图片标题&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;标题&#34;&gt;标题&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://daringfireball.net/projects/markdown/syntax#header&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;Atx&lt;/code&gt;方式标记标题&lt;/p&gt;

&lt;h1 id=&#34;一级标题&#34;&gt;一级标题&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;# 一级标题&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;二级标题&#34;&gt;二级标题&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;## 二级标题&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;三级标题&#34;&gt;三级标题&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;### 三级标题&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;四级标题&#34;&gt;四级标题&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;#### 四级标题&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;五级标题&#34;&gt;五级标题&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;##### 五级标题&lt;/code&gt;&lt;/p&gt;

&lt;h6 id=&#34;六级标题&#34;&gt;六级标题&lt;/h6&gt;

&lt;p&gt;&lt;code&gt;###### 六级标题&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;你也可以使用&lt;code&gt;Setext&lt;/code&gt;方式来标记标题.&lt;/p&gt;

&lt;h1 id=&#34;一级标题-使用-号&#34;&gt;一级标题(使用=号)&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;一级标题(使用=号)
==============================
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二级标题-使用-号&#34;&gt;二级标题(使用-号)&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;二级标题(使用-号)
-------------
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;段落&#34;&gt;段落&lt;/h2&gt;

&lt;p&gt;Markdown文本段落之间通过空行进行分隔，
直接回车换行不会产生一个新的段落，
上下两行中间不加空行会连接成一个段落。&lt;br /&gt;
示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是一个段落

这是另外一个段落
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;p&gt;这是一个段落&lt;/p&gt;

&lt;p&gt;这是另外一个段落&lt;/p&gt;

&lt;p&gt;如果你只是想进行换行而不是需要一个段落，可以在一行结尾处添加两个以上的空格。&lt;br /&gt;
示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是一行结尾。[空格][空格]
这行接着上一行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果&lt;/p&gt;

&lt;p&gt;这是一行结尾。&lt;br /&gt;
这行接着上一行。&lt;/p&gt;

&lt;p&gt;不要使用空格或者&lt;code&gt;tab&lt;/code&gt;来缩进段落。&lt;/p&gt;

&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;

&lt;p&gt;Markdown使用&lt;code&gt;&amp;gt;&lt;/code&gt;来标记引用, 在每一行引用前添加&lt;code&gt;&amp;gt;&lt;/code&gt;符号。&lt;br /&gt;
示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 这是一个引用，它有两个段落。
&amp;gt;
&amp;gt; 这是第二个段落。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这是一个引用，它有两个段落。&lt;/p&gt;

&lt;p&gt;这是第二个段落。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;引用可以嵌套使用。&lt;br /&gt;
示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 这是外面的引用
&amp;gt;
&amp;gt; &amp;gt; 这是里面的引用
&amp;gt;
&amp;gt; 这是外面的引用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这是外面的引用&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这是里面的引用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是外面的引用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;引用中也可以使用其它Markdown的标记，如标题、列表、代码块等。&lt;br /&gt;
示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;&amp;gt; ## 这是一个标题
&amp;gt;
&amp;gt; 1. 这是有序列表的第一行
&amp;gt; 2. 这是有序列表的第二行
&amp;gt;
&amp;gt; 引用内放置代码:
&amp;gt;
&amp;gt;     return shell_exec(&amp;quot;echo $input | $markdown_script&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;这是一个标题&#34;&gt;这是一个标题&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;这是有序列表的第一行&lt;/li&gt;
&lt;li&gt;这是有序列表的第二行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;引用内放置代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return shell_exec(&amp;quot;echo $input | $markdown_script&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;列表&#34;&gt;列表&lt;/h2&gt;

&lt;p&gt;Markdown支持有序和无序列表。&lt;/p&gt;

&lt;p&gt;列表项标记位于列表左边，后面至少有一个空格或者一个tab。&lt;/p&gt;

&lt;p&gt;无序列表可以使用&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt;或者&lt;code&gt;-&lt;/code&gt;作为列表项标记，你也可以混用它们。&lt;br /&gt;
示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* Red
+ Green
- Blue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有序列表使用一个数字后跟一个小数点(.)来作为列表项标记，注意，数字可以是任意的，如下。&lt;br /&gt;
示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 第一行
1. 第二行
1. 第三行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;第一行&lt;/li&gt;
&lt;li&gt;第二行&lt;/li&gt;
&lt;li&gt;第三行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 从上面可以看出，列表第几行与前面数字并无关系，只需要是个数字即可，最终显示的数字以实际在第几行来定。
但是一般来说，使用有序的数字让人容易理解。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 第一行
2. 第二行
3. 第三行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列表也是可以嵌套的，每一级嵌套列表必须使用4个空格或者一个tab。&lt;br /&gt;
示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 无序列表第三行，以`*`开始
+ 无序列表第三行，以`+`开始
	* 这是嵌套的无序列表第一行，使用了4个空格进行缩进
	* 这是嵌套的无序列表第二行，使用了一次tab进行缩进
- 无序列表第三行，以`-`开始
    1. 这是嵌套的有序列表第一行，使用了4个空格进行缩进
        1. 这是嵌套的有序列表中嵌套的有序列表第一行，以8个空格缩进
	    1. 这是嵌套的有序列表中嵌套的有序列表第二行，使用了一次tab加4个空格缩进
	1. 这是嵌套的有序列表第二行，使用了一次tab进行缩进

		这是第一个嵌套段落，使用了两次tab进行缩进，上下有空行

	    * 这是嵌套的有序列表中嵌套的无序列表第一行，使用了一次tab加4个空格缩进
		* 这是嵌套的有序列表中嵌套的无序列表第二行，使用了两次tab缩进

	    这是第一个嵌套段落，使用了一次tab加4个空格进行缩进，上下有空行

	1. 这是嵌套的有序列表第三行，使用了一次tab进行缩进
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无序列表第三行，以&lt;code&gt;*&lt;/code&gt;开始&lt;/li&gt;
&lt;li&gt;无序列表第三行，以&lt;code&gt;+&lt;/code&gt;开始

&lt;ul&gt;
&lt;li&gt;这是嵌套的无序列表第一行，使用了4个空格进行缩进&lt;/li&gt;
&lt;li&gt;这是嵌套的无序列表第二行，使用了一次tab进行缩进&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无序列表第三行，以&lt;code&gt;-&lt;/code&gt;开始&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;这是嵌套的有序列表第一行，使用了4个空格进行缩进

&lt;ol&gt;
&lt;li&gt;这是嵌套的有序列表中嵌套的有序列表第一行，以8个空格缩进&lt;/li&gt;
&lt;li&gt;这是嵌套的有序列表中嵌套的有序列表第二行，使用了一次tab加4个空格缩进&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这是嵌套的有序列表第二行，使用了一次tab进行缩进&lt;/p&gt;

&lt;p&gt;这是第一个嵌套段落，使用了两次tab进行缩进，上下有空行&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这是嵌套的有序列表中嵌套的无序列表第一行，使用了一次tab加4个空格缩进&lt;/li&gt;
&lt;li&gt;这是嵌套的有序列表中嵌套的无序列表第二行，使用了两次tab缩进&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是第一个嵌套段落，使用了一次tab加4个空格进行缩进，上下有空行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这是嵌套的有序列表第三行，使用了一次tab进行缩进&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你也可以在列表中嵌套一个引用块。&lt;br /&gt;
示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 第一行

	&amp;gt; 这里是内嵌的引用块，前面有一个空行，使用了一次tab缩进
1. 第二行
1. 第三行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第一行&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这里是内嵌的引用块，前面有一个空行，使用了一次tab缩进&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第三行&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你也可以在列表中嵌套代码块。&lt;br /&gt;
示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 列表第一项

    内嵌段落，以4个空格缩进，前后有空行:

        这是内嵌的代码块，以8个空格缩进，前后有空行。

	内嵌段落，使用一次tab缩进，前后有空行:

		这是内嵌的代码块，使用两次tab缩进，前后有空行!

* 列表第二项
* 列表第三项
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;列表第一项&lt;/p&gt;

&lt;p&gt;内嵌段落，以4个空格缩进，前后有空行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是内嵌的代码块，以8个空格缩进，前后有空行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内嵌段落，使用一次tab缩进，前后有空行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是内嵌的代码块，使用两次tab缩进，前后有空行!
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;列表第二项&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;列表第三项&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;表格&#34;&gt;表格&lt;/h2&gt;

&lt;p&gt;表格标记是使用&lt;code&gt;-&lt;/code&gt;和&lt;code&gt;|&lt;/code&gt;这两个符号。&lt;/p&gt;

&lt;p&gt;示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;表头第一列 | 表头第二列
------------- | -------------
表格第一行第一列  | 表格第一行第二列
表格第二行第一列  | 表格第二行第二列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表头第一列&lt;/th&gt;
&lt;th&gt;表头第二列&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;表格第一行第一列&lt;/td&gt;
&lt;td&gt;表格第一行第二列&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;表格第二行第一列&lt;/td&gt;
&lt;td&gt;表格第二行第二列&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在某些Markdown实现(如GFM)中，你还可以通过&lt;code&gt;:&lt;/code&gt;来实现对齐。&lt;br /&gt;
示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Right     | Left   | Center
---------:| :----- |:-----:
Computer  |  $1600 | one
Phone     |    $12 | three
Pipe      |     $1 | eleven
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果(此处因博客Markdown解析器不支持，故未能正确显示)：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;Right&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Left&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Center&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;Computer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$1600&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;one&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;Phone&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;three&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;Pipe&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;eleven&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;你也可以在表格中使用Markdown支持的内联标记:&lt;br /&gt;
示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;| Function name | Description                    |
| ------------- | ------------------------------ |
| `help()`      | Display the __help__ window.   |
| `destroy()`   | **Destroy your computer!**     |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Function name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;help()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Display the &lt;strong&gt;help&lt;/strong&gt; window.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;destroy()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Destroy your computer!&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;代码高亮&#34;&gt;代码高亮&lt;/h2&gt;

&lt;p&gt;在标准的Markdown实现中，代码块通过缩进(tab或者4个空格)来控制。&lt;br /&gt;
直到它遇到一行没有缩进的行(忽略中间的空行)或者文档末尾为止。&lt;br /&gt;
示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[tab][tab]这是代码块第一行，使用了两次tab进行缩进:

[tab][tab][tab]这是代码块第二行，使用了三次tab进行缩进，上面有一行空行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    这是代码块第一行，使用了两次tab进行缩进:

        这是代码块第二行，使用了三次tab进行缩进
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要进行代码高亮，可以使用&lt;code&gt;```&lt;/code&gt;或者&lt;code&gt;~~~&lt;/code&gt;将代码块包括进来。&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：代码高亮不是Markdown标准的一部份，在不同实现中可能会有不同的效果。&lt;br /&gt;
示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```js
var a = 3;
var b = function () {
    var c = &#39;hello&#39;;
};
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a = 3;
var b = function () {
    var c = &#39;hello&#39;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~~~~
var a = 3;
var b = function () {
    var c = &#39;hello&#39;;
};
~~~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a = 3;
var b = function () {
  var c = &#39;hello&#39;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码块标记&lt;code&gt;`&lt;/code&gt;或者&lt;code&gt;~&lt;/code&gt;至少是3个。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;水平分隔线&#34;&gt;水平分隔线&lt;/h2&gt;

&lt;p&gt;水平分隔线可以是以下几种形式。&lt;br /&gt;
示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* * *

***

*****

- - - -

-----------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果:&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt; 本文翻译改编自&lt;a href=&#34;https://bitbucket.org/tutorials/markdowndemo&#34;&gt;Bitbucket markdowndemo&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>两步验证(2-step verification)</title>
      <link>http://dmdgeeker.com/2016/08/28/%E4%B8%A4%E6%AD%A5%E9%AA%8C%E8%AF%812-step-verification/</link>
      <pubDate>Sun, 28 Aug 2016 14:36:06 +0800</pubDate>
      <author>xheavey@gmail.com (Allen Heavey)</author>
      <guid>http://dmdgeeker.com/2016/08/28/%E4%B8%A4%E6%AD%A5%E9%AA%8C%E8%AF%812-step-verification/</guid>
      <description>

&lt;h3 id=&#34;关于两步验证&#34;&gt;关于两步验证&lt;/h3&gt;

&lt;p&gt;两步验证是一种安全措施，用于保护某些资源不被泄露，即使在泄露了密码的情况下。
两步验证有多种方式，主要包括：短信、验证器、电话等方式。本文主要讲述验证器方式的两步验证。&lt;/p&gt;

&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;

&lt;p&gt;使用基于验证器方式的两步验证通常需要另外一部设备（通常是手机，也可能是其它硬件）。
用户在登录系统时，除了输入正常的密码外，还需要输入一个动态生成的密码。
此动态密码由另外一部可信设备提供，具有一个较短的时效性，保证不会重放攻击。&lt;/p&gt;

&lt;p&gt;动态密码生成通常有两种算法：TOTP与HOTP。&lt;/p&gt;

&lt;p&gt;TOTP(Time-Based One-Time Password)是指基于时间的一次性密码。&lt;br /&gt;
HOTP(HMAC-based One-time Password)是指基于计数的一次性密码。&lt;/p&gt;

&lt;p&gt;安全令牌硬件（如某些银行的动态密保，游戏账号的密码令牌）通常是基于HOTP方式实现。
其表现为使用专有硬件，为某一特定产品或系统服务。&lt;/p&gt;

&lt;p&gt;而当前大多数两步验证使用的是TOTP方式实现，比如Google Authenticator。&lt;/p&gt;

&lt;h3 id=&#34;totp流程&#34;&gt;TOTP流程&lt;/h3&gt;

&lt;p&gt;基于TOTP的两步验证流程一般通过需要先绑定，然后随用随验证。&lt;/p&gt;

&lt;p&gt;现假设有一系统&lt;code&gt;S&lt;/code&gt;，用户&lt;code&gt;A&lt;/code&gt;进行两步验证&lt;/p&gt;

&lt;p&gt;绑定流程一般如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用户&lt;code&gt;A&lt;/code&gt;注册/登录系统&lt;code&gt;S&lt;/code&gt;后，&lt;code&gt;S&lt;/code&gt;后台生成一个OTP链接，在前端生成并显示该链接的二维码&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用户&lt;code&gt;A&lt;/code&gt;用手机通过Google Authenticator之类的验证器&lt;code&gt;G&lt;/code&gt;扫描二维码进行绑定&lt;/li&gt;
&lt;li&gt;验证器&lt;code&gt;G&lt;/code&gt;会生成动态密码&lt;code&gt;C&lt;/code&gt;，用户&lt;code&gt;A&lt;/code&gt;将动态密码&lt;code&gt;C&lt;/code&gt;输入到系统&lt;code&gt;S&lt;/code&gt;的绑定验证框内&lt;/li&gt;
&lt;li&gt;如果系统&lt;code&gt;S&lt;/code&gt;后台验证该动态密码&lt;code&gt;C&lt;/code&gt;成功，则系统&lt;code&gt;S&lt;/code&gt;与验证器&lt;code&gt;G&lt;/code&gt;绑定成功。否则，绑定失败。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://dmdgeeker.com/images/2step-verification-bind.png&#34; alt=&#34;示意图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;验证流程如下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用户&lt;code&gt;A&lt;/code&gt;通过账号密码登录系统&lt;code&gt;S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;系统&lt;code&gt;S&lt;/code&gt;验证账号和密码匹配后，跳转到两步验证页面&lt;/li&gt;
&lt;li&gt;用户&lt;code&gt;A&lt;/code&gt;将验证器&lt;code&gt;G&lt;/code&gt;里的动态验证码&lt;code&gt;C&lt;/code&gt;输入到两步验证页面的验证框中&lt;/li&gt;
&lt;li&gt;系统&lt;code&gt;S&lt;/code&gt;对验证码&lt;code&gt;C&lt;/code&gt;进行验证，如果成功，如登录成功，否则失败&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;totp实现&#34;&gt;TOTP实现&lt;/h3&gt;

&lt;p&gt;可以按照上面所述流程，一步步来进行实现。
下面主要介绍几个关键部份。&lt;/p&gt;

&lt;h4 id=&#34;otp链接&#34;&gt;OTP链接&lt;/h4&gt;

&lt;p&gt;OTP链接格式: &lt;code&gt;otpauth://TYPE/LABEL?PARAMETERS&lt;/code&gt;。
具体可参考&lt;a href=&#34;https://github.com/google/google-authenticator/wiki/Key-Uri-Format&#34;&gt;Google Authenticator URI&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;code&gt;otpauth://totp/Google:alice@google.com?secret=JBSWY3DPEHPK3PXP&amp;amp;issuer=Google&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其中，前面一段&lt;code&gt;otpauth://totp/Example:alice@google.com&lt;/code&gt;中各部份的意义如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;otpauth&lt;/code&gt;表示OTP认证协议&lt;/li&gt;
&lt;li&gt;&lt;code&gt;totp&lt;/code&gt;表示使用TOTP算法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Google&lt;/code&gt;表示生成此链接的公司或软件名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alice@google.com&lt;/code&gt;表示该链接所对应的用户的用户名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而后面一段查询参数中各部份意义如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;secret&lt;/code&gt;是由服务端&lt;strong&gt;Base32&lt;/strong&gt;编码生成的字符串。其内容不重要，只要保证随机性即可，应保证每个用户都拥有一个独立的&lt;code&gt;secret&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;issuer&lt;/code&gt;表示生成此链接的公司或软件名称，应与前一段中相应部份一致。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;动态验证码生成&#34;&gt;动态验证码生成&lt;/h4&gt;

&lt;p&gt;动态验证码的生成算法是公开的，可以到此处进行查处：&lt;a href=&#34;https://tools.ietf.org/html/rfc6238&#34;&gt;RFC6238&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面给出Go语言版本示例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 6位数字动态验证码
var digits = 6

// secret 即为otpauth链接中的secret
// timeValue 为当前unix时间除以验证码失效时间（通常为30s）
func computeCode(secret string, timeValue int64) string {
	key, err := base32.StdEncoding.DecodeString(secret)
	if err != nil {
		return &amp;quot;&amp;quot;
	}

	hash := hmac.New(sha1.New, key)
	err = binary.Write(hash, binary.BigEndian, timeValue)
	if err != nil {
		return &amp;quot;&amp;quot;
	}
	h := hash.Sum(nil)

	offset := h[len(h)-1] &amp;amp; 0x0f
	val := ((int(h[offset]) &amp;amp; 0x7f) &amp;lt;&amp;lt; 24) |
         ((int(h[offset+1] &amp;amp; 0xff)) &amp;lt;&amp;lt; 16) |
         ((int(h[offset+2] &amp;amp; 0xff)) &amp;lt;&amp;lt; 8) |
         (int(h[offset+3]) &amp;amp; 0xff)
	otp := int64(val) % int64(math.Pow10(digits))
	code := fmt.Sprintf(fmt.Sprintf(&amp;quot;%%0%dd&amp;quot;, digits), otp)
	return code
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;两步验证的优缺点&#34;&gt;两步验证的优缺点&lt;/h3&gt;

&lt;p&gt;两步验证的优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;系统的安全性提高，即使其它网站泄露了用户的明文密码，仍可以保证用户账户不受攻击。&lt;/li&gt;
&lt;li&gt;动态按时间生成验证码，防止重放攻击。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两步验证的缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;复杂度提高。用户不仅需要输入密码，还需要输入动态验证码。&lt;/li&gt;
&lt;li&gt;需要另一个可信设备。即默认用户在绑定时候所使用的设备是安全的。&lt;/li&gt;
&lt;li&gt;当验证器不可用时（设备丢失或不在身边），无法登录。&lt;/li&gt;
&lt;li&gt;适合web端登录，不适合移动应用登录&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;其它验证方式&#34;&gt;其它验证方式&lt;/h3&gt;

&lt;p&gt;一、短信认证&lt;br /&gt;
短信验证码方式可能是当前中国各大厂商用得最多的一种验证方式。
在用户绑定某个手机号后，将用户与此手机号关联。在有需要进行二次验证的地方，
发送二次验证码短信，用户接收短信并输入该验证码。&lt;/p&gt;

&lt;p&gt;二、扫码认证&lt;br /&gt;
这在微信登录桌面端与web端的唯一方式。
如果你在桌面web端使用支付宝，通常也可以通过手机支付宝扫页面上二维码进行支付确认。&lt;/p&gt;

&lt;p&gt;三、推送认证&lt;br /&gt;
当微信桌面端已登录过，保存有信息时，通常会推送一条登录请求给手机微信端，需要在手机端确认。&lt;/p&gt;

&lt;h3 id=&#34;引用&#34;&gt;引用&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.google.com/landing/2step/&#34;&gt;Google 两步验证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://support.apple.com/zh-cn/HT204152&#34;&gt;Apple 两步验证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://support.apple.com/zh-cn/HT204915&#34;&gt;Apple 双重认证&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Authority &amp; Merit</title>
      <link>http://dmdgeeker.com/2016/08/24/authority--merit/</link>
      <pubDate>Wed, 24 Aug 2016 00:37:55 +0800</pubDate>
      <author>xheavey@gmail.com (Allen Heavey)</author>
      <guid>http://dmdgeeker.com/2016/08/24/authority--merit/</guid>
      <description>&lt;p&gt;@reference: &lt;a href=&#34;https://medium.com/@jack/authority-merit-80ad140f990b#.bzbk58i5n&#34;&gt;Medium&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;An email to the team at Square.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Subject: Authority &amp;amp; Merit&lt;br /&gt;
From: Jack Dorsey&lt;br /&gt;
X-Mailer: iPhone Mail (9B206)&lt;br /&gt;
Date: Wed, 5 Sep 2012 15:08:02 -0700&lt;br /&gt;
To: Square&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Squares,&lt;/p&gt;

&lt;p&gt;I’ve noticed a funny thing in the company. There’s been a high occurrence of folks using names, mine for instance, to push through an idea. “Jack really wants this to happen, Jack thinks this is an amazing idea, Jack said, etc.” This is obviously counter to the meritocracy/marketplace of ideas we want to build. Using someone else’s name to sell an idea does two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It diminishes your authority.&lt;/li&gt;
&lt;li&gt;It diminishes the idea’s merit.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Simply: if you have to use someone else’s name or authority to get a point across, there is little merit to the point (you might not believe it yourself). If you believe in something to be correct, focus on showing your work to prove it. Authority derives naturally from merit, not the other way around.&lt;/p&gt;

&lt;p&gt;We want more passionate debates about bold and crazy ideas rethinking what we’ve taken for granted rather than discussions that end in “John wants this, this is how we’re supposed to do it.” The former will keep us agile and innovative, the latter will make us irrelevant.&lt;/p&gt;

&lt;p&gt;Jack&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Good Product Manager/Bad Product Manager</title>
      <link>http://dmdgeeker.com/2016/08/24/good-product-manager/bad-product-manager/</link>
      <pubDate>Wed, 24 Aug 2016 00:34:11 +0800</pubDate>
      <author>xheavey@gmail.com (Allen Heavey)</author>
      <guid>http://dmdgeeker.com/2016/08/24/good-product-manager/bad-product-manager/</guid>
      <description>&lt;p&gt;@reference: &lt;a href=&#34;http://a16z.com/2012/06/15/good-product-managerbad-product-manager/&#34;&gt;a16z&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Warning: This document was written 15 years ago and is probably not relevant for today’s product managers. I present it here merely as an example of a useful training document.&lt;/p&gt;

&lt;p&gt;Good product managers know the market, the product, the product line and the competition extremely well and operate from a strong basis of knowledge and confidence. A good product manager is the CEO of the product. A good product manager takes full responsibility and measures themselves in terms of the success of the product. The are responsible for right product/right time and all that entails. A good product manager knows the context going in (the company, our revenue funding, competition, etc.), and they take responsibility for devising and executing a winning plan (no excuses).&lt;/p&gt;

&lt;p&gt;Bad product managers have lots of excuses. Not enough funding, the engineering manager is an idiot, Microsoft has 10 times as many engineers working on it, I’m overworked, I don’t get enough direction. Barksdale doesn’t make these kinds of excuses and neither should the CEO of a product.&lt;/p&gt;

&lt;p&gt;Good product managers don’t get all of their time sucked up by the various organizations that must work together to deliver right product right time. They don’t take all the product team minutes, they don’t project manage the various functions, they are not gophers for engineering. They are not part of the product team; they manage the product team. Engineering teams don’t consider Good Product Managers a “marketing resource.” Good product managers are the marketing counterpart of the engineering manager. Good product managers crisply define the target, the “what” (as opposed to the how) and manage the delivery of the “what.” Bad product managers feel best about themselves when they figure out “how”. Good product managers communicate crisply to engineering in writing as well as verbally. Good product managers don’t give direction informally. Good product managers gather information informally.&lt;/p&gt;

&lt;p&gt;Good product managers create leveragable collateral, FAQs, presentations, white papers. Bad product managers complain that they spend all day answering questions for the sales force and are swamped. Good product managers anticipate the serious product flaws and build real solutions. Bad product managers put out fires all day. Good product managers take written positions on important issues (competitive silver bullets, tough architectural choices, tough product decisions, markets to attack or yield). Bad product managers voice their opinion verbally and lament that the “powers that be” won’t let it happen. Once bad product managers fail, they point out that they predicted they would fail.&lt;/p&gt;

&lt;p&gt;Good product managers focus the team on revenue and customers. Bad product managers focus team on how many features Microsoft is building. Good product managers define good products that can be executed with a strong effort. Bad product managers define good products that can’t be executed or let engineering build whatever they want (i.e. solve the hardest problem).
Good product managers think in terms of delivering superior value to the market place during inbound planning and achieving market share and revenue goals during outbound. Bad product managers get very confused about the differences amongst delivering value, matching competitive features, pricing, and ubiquity. Good product managers decompose problems. Bad product managers combine all problems into one.&lt;/p&gt;

&lt;p&gt;Good product managers think about the story they want written by the press. Bad product managers think about covering every feature and being really technically accurate with the press. Good product managers ask the press questions. Bad product managers answer any press question. Good product managers assume press and analyst people are really smart. Bad product managers assume that press and analysts are dumb because they don’t understand the difference between “push” and “simulated push.”
Good product managers err on the side of clarity vs. explaining the obvious. Bad product managers never explain the obvious. Good product managers define their job and their success. Bad product managers constantly want to be told what to do.&lt;/p&gt;

&lt;p&gt;Good product managers send their status reports in on time every week, because they are disciplined. Bad product managers forget to send in their status reports on time, because they don’t value discipline.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;@June 15, 2012&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>TiDB 集群安装</title>
      <link>http://dmdgeeker.com/2016/07/28/tidb-%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</link>
      <pubDate>Thu, 28 Jul 2016 10:20:25 +0800</pubDate>
      <author>xheavey@gmail.com (Allen Heavey)</author>
      <guid>http://dmdgeeker.com/2016/07/28/tidb-%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</guid>
      <description>

&lt;h1 id=&#34;安装-tidb&#34;&gt;安装 TiDB&lt;/h1&gt;

&lt;p&gt;TiDB 需要安装 TiKV，RocksDB, PD等软件。&lt;/p&gt;

&lt;h3 id=&#34;环境&#34;&gt;环境&lt;/h3&gt;

&lt;p&gt;Ubuntu 14.04.4 (64bit)&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://0xffff.me/install-tidb-tikv-on-centos-7/&#34;&gt;CentOS 7 安装&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/pingcap/tikv/blob/master/USAGE.md&#34;&gt;TiKV Usage&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;编译二进制文件&#34;&gt;编译二进制文件&lt;/h2&gt;

&lt;p&gt;二进制程序如&lt;code&gt;tidb-server&lt;/code&gt;, &lt;code&gt;tikv-server&lt;/code&gt;, &lt;code&gt;pd-server&lt;/code&gt;都可以在一台主机上编译后分发到其它主机上去，只要保持主机环境基本一致即可。&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;RocksDB&lt;/code&gt;是编译成动态库文件，在不同主机上共享比较麻烦（甚至无法共享？），所以建议每台放置TiKV组件的主机上都进行一次编译。&lt;/p&gt;

&lt;h3 id=&#34;编译pd&#34;&gt;编译PD&lt;/h3&gt;

&lt;p&gt;1）安装Golang&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;wget https://storage.googleapis.com/golang/go1.6.3.linux-amd64.tar.gz
tar -C /usr/local -xzf go1.6.3.linux-amd64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）编译PD&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/pingcap/pd
cd pd
make build
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装rocksdb&#34;&gt;安装RocksDB&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;apt-get update
apt-get install libgflags-dev libsnappy-dev zlib1g-dev libbz2-dev liblz4-dev -y
wget https://github.com/facebook/rocksdb/archive/v4.8.tar.gz
tar xzvf v4.8.tar.gz
cd rocksdb-4.8
make shared_lib -j4
cp librocksdb.so.4.8.0 /usr/local/lib
ln -fs /usr/local/lib/librocksdb.so.4.8.0 /usr/local/lib/librocksdb.so
ln -fs /usr/local/lib/librocksdb.so.4.8.0 /usr/local/lib/librocksdb.so.4
ln -fs /usr/local/lib/librocksdb.so.4.8.0 /usr/local/lib/librocksdb.so.4.8
ldconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;编译tikv&#34;&gt;编译TiKV&lt;/h3&gt;

&lt;p&gt;1）安装rust&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl -sSf https://static.rust-lang.org/rustup.sh | sh -s -- --channel=nightly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）编译TiKV&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/pingcap/tikv
cd tikv
make release
cp target/release/tikv-server /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;编译tidb&#34;&gt;编译TiDB&lt;/h3&gt;

&lt;p&gt;1）安装Golang&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;wget https://storage.googleapis.com/golang/go1.6.3.linux-amd64.tar.gz
tar -C /usr/local -xzf go1.6.3.linux-amd64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）编译TiDB&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/pingcap/tidb.git $GOPATH/src/github.com/pingcap/tidb
cd $GOPATH/src/github.com/pingcap/tidb
make server
cp $GOPATH/bin/tidb-server /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;运行tidb&#34;&gt;运行TiDB&lt;/h2&gt;

&lt;p&gt;运行TiDB需要依次运行：pd, tikv, tidb&lt;/p&gt;

&lt;h3 id=&#34;架构分布&#34;&gt;架构分布&lt;/h3&gt;

&lt;p&gt;TiDB:    192.168.100.3, 192.168.100.4, 192.168.100.5&lt;br /&gt;
PD:       192.168.100.6, 192.168.100.7, 192.168.100.8&lt;br /&gt;
TiKV:     192.168.100.9, 192.168.100.10, 192.168.100.11&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://dmdgeeker.com/images/tidb-cluster-machines.png&#34; alt=&#34;Hosts&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;运行pd&#34;&gt;运行pd&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 需要在很短时间将几个pd-server同时运行起来，否则会造成找不到的状况，然后一个一个出错退出。&lt;/p&gt;

&lt;p&gt;1) pd1（在192.168.100.6这台主机上运行）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pd-server --cluster-id=1 \
      --addr=&amp;quot;192.168.100.6:1234&amp;quot; \
      --advertise-addr=&amp;quot;192.168.100.6:1234&amp;quot; \
      --http-addr=&amp;quot;192.168.100.6:9090&amp;quot; \
      --etcd-name=pd1 \
      --etcd-advertise-client-url=&amp;quot;http://192.168.100.6:2379&amp;quot; \
      --etcd-advertise-peer-url=&amp;quot;http://192.168.100.6:2380&amp;quot; \
      --etcd-initial-cluster=&amp;quot;pd1=http://192.168.100.6:2380,pd2=http://192.168.100.7:2380,pd3=http://192.168.100.8:2380&amp;quot; \
      --etcd-listen-peer-url=&amp;quot;http://192.168.100.6:2380&amp;quot; \
      --etcd-listen-client-url=&amp;quot;http://192.168.100.6:2379&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2) pd2（在192.168.100.7这台主机上运行）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pd-server --cluster-id=1 \
      --addr=&amp;quot;192.168.100.7:1234&amp;quot; \
      --advertise-addr=&amp;quot;192.168.100.7:1234&amp;quot; \
      --http-addr=&amp;quot;192.168.100.7:9090&amp;quot; \
      --etcd-name=pd2 \
      --etcd-advertise-client-url=&amp;quot;http://192.168.100.7:2379&amp;quot; \
      --etcd-advertise-peer-url=&amp;quot;http://192.168.100.7:2380&amp;quot; \
      --etcd-initial-cluster=&amp;quot;pd1=http://192.168.100.6:2380,pd2=http://192.168.100.7:2380,pd3=http://192.168.100.8:2380&amp;quot; \
      --etcd-listen-peer-url=&amp;quot;http://192.168.100.7:2380&amp;quot; \
      --etcd-listen-client-url=&amp;quot;http://192.168.100.7:2379&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) pd3（在192.168.100.8这台主机上运行）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pd-server --cluster-id=1 \
      --addr=&amp;quot;192.168.100.8:1234&amp;quot; \
      --advertise-addr=&amp;quot;192.168.100.8:1234&amp;quot; \
      --http-addr=&amp;quot;192.168.100.8:9090&amp;quot; \
      --etcd-name=pd3 \
      --etcd-advertise-client-url=&amp;quot;http://192.168.100.8:2379&amp;quot; \
      --etcd-advertise-peer-url=&amp;quot;http://192.168.100.8:2380&amp;quot; \
      --etcd-initial-cluster=&amp;quot;pd1=http://192.168.100.6:2380,pd2=http://192.168.100.7:2380,pd3=http://192.168.100.8:2380&amp;quot; \
      --etcd-listen-peer-url=&amp;quot;http://192.168.100.8:2380&amp;quot; \
      --etcd-listen-client-url=&amp;quot;http://192.168.100.8:2379&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行tikv&#34;&gt;运行TiKV&lt;/h3&gt;

&lt;p&gt;由于TiKV依赖于RocksDB，所以需要先安装RocksDB。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; TiKV二进制文件&lt;strong&gt;tikv-server&lt;/strong&gt;可以在一台主机上编译了放到其它主机上运行，但是RocksDB好像不可以。
所以每一台主机上都需要进行一次RocksDB的安装。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装RocksDB&lt;br /&gt;
在192.168.100.9, 192.168.100.10, 192.168.100.11 这三台主机上，分别进行RocksDB的安装。&lt;/li&gt;
&lt;li&gt;将编译过后的&lt;strong&gt;tikv-server&lt;/strong&gt;文件分发到上面三台主机上，放到系统PATH目录中。&lt;/li&gt;
&lt;li&gt;运行TiKV&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 在192.168.100.9这台主机上运行
tikv-server -S raftkv --addr 192.168.100.9:5050 --etcd 192.168.100.6:2379,192.168.100.7:2379,192.168.100.8:2379 -s /data --cluster-id 1

# 在192.168.100.10这台主机上运行
tikv-server -S raftkv --addr 192.168.100.10:5050 --etcd 192.168.100.6:2379,192.168.100.7:2379,192.168.100.8:2379 -s /data --cluster-id 1

# 在192.168.100.11这台主机上运行
tikv-server -S raftkv --addr 192.168.100.11:5050 --etcd 192.168.100.6:2379,192.168.100.7:2379,192.168.100.8:2379 -s /data --cluster-id 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行tidb-1&#34;&gt;运行TiDB&lt;/h3&gt;

&lt;p&gt;将&lt;strong&gt;tidb-server&lt;/strong&gt;分发到192.168.100.3, 192.168.100.4, 192.168.100.5这三台主机上去，放置于类似/usr/local/bin目录中。&lt;/p&gt;

&lt;p&gt;在这三台主机上都运行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;tidb-server --store=tikv --path=&amp;quot;192.168.100.6:2379,192.168.100.7:2379,192.168.100.8:2379/pd?cluster=1&amp;quot; -lease 1 -P 3306
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;反向代理&#34;&gt;反向代理&lt;/h3&gt;

&lt;p&gt;三台TiDB同时运行，三者互不干涉，需要一个反向代理来进行负载均衡与流量分发。这里使用的是Nginx 1.10.1来进行TCP反向代理。&lt;/p&gt;

&lt;h3 id=&#34;效果图&#34;&gt;效果图&lt;/h3&gt;

&lt;p&gt;使用客户端连接，效果图如下：
&lt;img src=&#34;http://dmdgeeker.com/images/tidb-cluster-client.png&#34; alt=&#34;Client&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;后记&#34;&gt;后记&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt; 上面各台主机上运行的命令都是使用tmux前台运行的。
如果没有使用&lt;code&gt;systemd&lt;/code&gt;或&lt;code&gt;supervisor&lt;/code&gt;之类工具进行启动的话，最好使用&lt;code&gt;nohup&lt;/code&gt;或者&lt;code&gt;tmux&lt;/code&gt;与&lt;code&gt;screen&lt;/code&gt;等方式运行。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>