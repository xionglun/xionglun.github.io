<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dev on X blog</title>
    <link>http://dmdgeeker.com/tags/dev/index.xml</link>
    <description>Recent content in Dev on X blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <managingEditor>xheavey@gmail.com (Allen Heavey)</managingEditor>
    <webMaster>xheavey@gmail.com (Allen Heavey)</webMaster>
    <copyright>(c) 2016-2017 Allen Heavey.</copyright>
    <atom:link href="http://dmdgeeker.com/tags/dev/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>gRPC基本使用</title>
      <link>http://dmdgeeker.com/2017/02/16/grpc%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 16 Feb 2017 19:00:00 +0800</pubDate>
      <author>xheavey@gmail.com (Allen Heavey)</author>
      <guid>http://dmdgeeker.com/2017/02/16/grpc%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      <description>

&lt;p&gt;通过RPC，客户端的应用程序可以方便地调用另外一台机器上的服务端程序，就像调用本地函数一样。&lt;/p&gt;

&lt;h3 id=&#34;安装grpc&#34;&gt;安装gRPC&lt;/h3&gt;

&lt;p&gt;标准安装可参考&lt;a href=&#34;https://github.com/grpc/grpc/blob/master/INSTALL.md&#34;&gt;gRPC Install&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里摘录不同语言安装gRPC时的操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C++          从源代码编译
C#           NuGet包Grpc
Go           go get google.golang.org/grpc
Node         npm install grpc
PHP          pecl install grpc
Python       pip install grpcio
Ruby         gem install grpc
Java         参考 github.com/grpc/grpc-java
Objective-C  参考 github.com/grpc/grpc/tree/master/src/objective-c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认gRPC使用的是&lt;a href=&#34;https://github.com/google/protobuf&#34;&gt;Protocol buffers&lt;/a&gt;，所以默认还需要安装&lt;strong&gt;protobuf&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果是Mac操作系统，可以这样同时安装gRPC系列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew tap grpc/grpc
brew install --with-plugins grpc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样安装的gRPC会同时安装&lt;code&gt;protoc&lt;/code&gt;，&lt;code&gt;grpc_cpp_plugin&lt;/code&gt;, &lt;code&gt;grpc_node_plugin&lt;/code&gt;, &lt;code&gt;grpc_php_plugin&lt;/code&gt;, &lt;code&gt;grpc_python_plugin&lt;/code&gt;, &lt;code&gt;grpc_csharp_plugin&lt;/code&gt;, &lt;code&gt;grpc_objective_c_plugin&lt;/code&gt;, &lt;code&gt;grpc_ruby_plugin&lt;/code&gt;这些可执行文件。&lt;/p&gt;

&lt;h3 id=&#34;编写protobuf文件&#34;&gt;编写protobuf文件&lt;/h3&gt;

&lt;p&gt;由于gRPC默认使用protobuf作为传输格式，所以这里需要先编写相应proto文件。示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;syntax = &amp;quot;proto3&amp;quot;;

option java_multiple_files = true;
option java_package = &amp;quot;io.grpc.examples.hello&amp;quot;;
option java_outer_classname = &amp;quot;HelloProto&amp;quot;;
option objc_class_prefix = &amp;quot;HL&amp;quot;;

package hello;

// The greeting service definition.
service Greeter {
    // Sends a greeting
    rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user&#39;s name.
message HelloRequest {
    string name = 1;
}

// The response message containing the greetings
message HelloReply {
    string message = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用的是&lt;strong&gt;proto3&lt;/strong&gt;语法，详细规则请参看Protobuf项目。&lt;/p&gt;

&lt;h3 id=&#34;编译成相应源文件&#34;&gt;编译成相应源文件&lt;/h3&gt;

&lt;p&gt;不同的语言进行编译的时候，所使用的参数大同小异，但是略有差别(特别是生成的文件)，使用过程中需要留意。&lt;/p&gt;

&lt;p&gt;各语言编译（注意此处的grpc_xxx_plugin是上面安装的，如果没有安装或者是其它系统，请自行先安装）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 假设上面的proto文件保存在当前目录的protos目录下，文件名为hello.proto

# Python; 生成文件 ./hello/hello_pb2.py
protoc -I protos --plugin=grpc_python_plugin --python_out=./hello ./protos/*.proto

# PHP; 生成目录./hello/Hello/ 与./hello/GPBMetadata/，目录下有相关文件
protoc -I protos --plugin=grpc_php_plugin --php_out=./hello ./protos/*.proto

# Node.js; 生成文件 ./hello/hello_grpc_pb.js与./hello/hello_pb.js
protoc -I protos --js_out=import_style=commonjs,binary:./hello/ --grpc_out=./hello --plugin=protoc-gen-grpc=$(which grpc_node_plugin) ./protos/*.proto

# Java
#protoc --plugin=protoc-gen-grpc-java=/path/to/protoc-gen-grpc-java --grpc-java_out=$DST_DIR --proto_path=$SRC_DIR $SRC_DIR/jr.proto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译Go代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;protoc -I protos --go_out=plugins=grpc:./hello ./protos/*.proto

# -I            导入路径，默认是当前文件夹，使用-I参数可以去掉生成代码目录树继承的问题
# --go_out      编译成go代码时输出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 在gRPC的编译时，Java与Go的编译与其它语言稍有区别，Java使用可参考&lt;a href=&#34;http://blog.jrwang.me/2016/grpc-at-first-view/&#34;&gt;gRPC 初探&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;启动grpc服务端&#34;&gt;启动gRPC服务端&lt;/h3&gt;

&lt;p&gt;这里以Go语言为例，上面proto文件生成的Go语言代码&lt;code&gt;hello.pb.go&lt;/code&gt;文件，
其文件内容与&lt;a href=&#34;https://github.com/grpc/grpc-go/blob/master/examples/helloworld/helloworld/helloworld.pb.go&#34;&gt;gRPC helloworld.pb.go&lt;/a&gt;这个文件类似（唯一不同之处是包名由hello变成了helloworld）。&lt;/p&gt;

&lt;p&gt;这里在项目根目录 &lt;em&gt;trpc&lt;/em&gt; 下创建一个&lt;code&gt;main.go&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;net&amp;quot;

	pb &amp;quot;trpc/hello&amp;quot;

	&amp;quot;golang.org/x/net/context&amp;quot;
	&amp;quot;google.golang.org/grpc&amp;quot;
)

type server struct{}

func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (re *pb.HelloReply, err error) {
	fmt.Println(&amp;quot;gRPC called!&amp;quot;)
	re = &amp;amp;pb.HelloReply{Message: &amp;quot;Hello, &amp;quot; + in.Name}
	return
}

func main() {
	ln, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:8081&amp;quot;)
	if err != nil {
		panic(err)
	}
	s := grpc.NewServer()
	pb.RegisterGreeterServer(s, &amp;amp;server{})
	s.Serve(ln)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将项目编译后运行，其监听在8081端口。&lt;/p&gt;

&lt;h3 id=&#34;运行grpc客户端&#34;&gt;运行gRPC客户端&lt;/h3&gt;

&lt;p&gt;这里以Node.js客户端为例，Node的客户端调用有两种方式：动态引用与静态生成。&lt;/p&gt;

&lt;p&gt;首先新建一个项目，安装gRPC，然后&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir noderpc
cd noderpc
npm init
npm i grpc --save
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;动态引用（动态引用方式无须先编译proto文件）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const grpc = require(&#39;grpc&#39;);

const protoPath = &#39;./protos/hello.proto&#39;;
let loader = grpc.load(protoPath);
let helloProto = loader.hello;

function greet() {
  let client = new helloProto.Greeter(&#39;localhost:8081&#39;, grpc.credentials.createInsecure());
  client.sayHello({name: &#39;beijing&#39;}, (err, resp) =&amp;gt; {
    if (err) {
      console.error(err);
    } else {
      console.log(resp.message);
    }
  });
}
greet();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;静态编译方式&lt;/p&gt;

&lt;p&gt;静态编译需要先将proto文件编译成javascript文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;protoc -I protos --js_out=import_style=commonjs,binary:./lib/ --grpc_out=./lib --plugin=protoc-gen-grpc=$(which grpc_node_plugin) ./protos/hello.proto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在代码中引用这两个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const grpc = require(&#39;grpc&#39;);
const svc = require(&#39;./lib/hello_grpc_pb.js&#39;);
const msg = require(&#39;./lib/hello_pb.js&#39;);

function greet() {
  let req = new msg.HelloRequest();
  req.setName(&amp;quot;beijin&amp;quot;);

  let client = new svc.GreeterClient(&#39;localhost:8041&#39;, grpc.credentials.createInsecure());
  client.sayHello(req, (err, resp) =&amp;gt; {
    if (err) {
      console.error(err);
    } else {
      console.log(resp.getMessage());
    }
  });

}
greet();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多更详细的示例请阅读&lt;a href=&#34;https://github.com/grpc/grpc/tree/master/examples&#34;&gt;gRPC examples&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;引用资料&#34;&gt;引用资料&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jianshu.com/p/774b38306c30&#34;&gt;gRPC初体验&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/shidaping/article/details/53942476&#34;&gt;gRPC Node.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yushuangqi.com/blog/2016/golang-grpcshi-jian--lian-zai-yi--grpcjie-shao-yu-an-zhuang.html&#34;&gt;gRPC介绍与安装&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Linux定时器</title>
      <link>http://dmdgeeker.com/2017/02/15/linux%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Wed, 15 Feb 2017 19:00:00 +0800</pubDate>
      <author>xheavey@gmail.com (Allen Heavey)</author>
      <guid>http://dmdgeeker.com/2017/02/15/linux%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;在linux中，定时器一般是使用&lt;code&gt;cron&lt;/code&gt;这个系统工具来实现的。
但是，在systemd中也可以使用&lt;code&gt;Timer&lt;/code&gt;进行定时控制。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;cron&#34;&gt;Cron&lt;/h2&gt;

&lt;p&gt;在linux下，可以使用&lt;code&gt;crontab -e&lt;/code&gt;来编辑修改定时任务(重点在最后一行)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use &#39;*&#39; in these fields (for &#39;any&#39;).#
# Notice that tasks will be started based on the cron&#39;s system
# daemon&#39;s notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每项任务前五项为时间配置，第六项为待执行的命令。&lt;/p&gt;

&lt;p&gt;定时任务时间配置说明&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;范围&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;0~59&lt;/td&gt;
&lt;td&gt;minute&lt;/td&gt;
&lt;td&gt;每小时的第几分钟执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;0~23&lt;/td&gt;
&lt;td&gt;hour&lt;/td&gt;
&lt;td&gt;每天的第几个小时执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dom&lt;/td&gt;
&lt;td&gt;1~31&lt;/td&gt;
&lt;td&gt;day of month&lt;/td&gt;
&lt;td&gt;每月的第几天执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mon&lt;/td&gt;
&lt;td&gt;1~12&lt;/td&gt;
&lt;td&gt;month&lt;/td&gt;
&lt;td&gt;每年的第几个月执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dow&lt;/td&gt;
&lt;td&gt;0~6&lt;/td&gt;
&lt;td&gt;day of week&lt;/td&gt;
&lt;td&gt;每周的第几天执行, 0为星期天&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中月份mon也可以使用&lt;code&gt;jan~dec&lt;/code&gt;，而周dow也可以使用&lt;code&gt;sun~sat&lt;/code&gt;。即使用英文单词前三个字母，大小写无关。&lt;/p&gt;

&lt;p&gt;时间配置每一项设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;*  表示任意值，即每小时或者每天，每月
/  表示每隔*时
,  表示多项时间触发
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;*/2 * * * * /usr/local/bin/play    # 每隔2分钟(整点开始计算)执行play程序
30 11 * * * /bin/echo &amp;quot;tick tock&amp;quot;  # 每天11点30分输出tick tock
* * * * 1,3 /usr/local/bin/backup  # 每周一、周三进行备份操作
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果觉得上面有好几项配置太麻烦，可以使用下面简单时间配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@reboot            执行一次，系统重启后执行
@yearly            每年执行一次(0 0 1 1 *)
@annually          与@yearly相同
@monthly           每月执行一次(0 0 1 * *)
@weekly            每周执行一次(0 0 * * 0)
@daily             每天执行一次(0 0 * * *)
@midnight          与@daily相同，每晚0点执行一次
@hourly            每小时执行一次(0 * * * *)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;@reboot /bin/echo &amp;quot;Startup&amp;quot;        # 在重启后打印Startup
@hourly /usr/local/bin/httpcheck   # 每小时进行httpcheck检查
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终&lt;code&gt;crontab -e&lt;/code&gt;文件内容始下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Edit this file to introduce tasks to be run by cron.
#
# ...省略了中间注释内容
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command
*/2 * * * * /usr/local/bin/play
30 11 * * * /bin/echo &amp;quot;tick tock&amp;quot;
* * * * 1,3 /usr/local/bin/backup
@reboot /bin/echo &amp;quot;Startup&amp;quot;
@hourly /usr/local/bin/httpcheck
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启&lt;code&gt;cron&lt;/code&gt;服务，使定时任务生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Systemd
systemctl restart cron.service

# Old Debian/Ubuntu
service cron restart

# Old CentOS/RHEL
service crond restart
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;timer&#34;&gt;Timer&lt;/h2&gt;

&lt;p&gt;在systemd中是以定时器(timer)去控制服务(service)来实现定时功能。&lt;/p&gt;

&lt;p&gt;一个典型的定时器文件以&lt;code&gt;.timer&lt;/code&gt;为后缀名。其内容大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Unit]
Description=Run weekly and on boot

[Timer]
# 在启动15分钟后执行
OnBootSec=15min
# 下一次执行是一周后
OnUnitActiveSec=1w
# 此处使用foo.service作为定时器执行的服务，默认使用与timer同名的服务
Unit=foo.service

[Install]
WantedBy=timers.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件中&lt;strong&gt;Timer&lt;/strong&gt;块其它选项包括:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;示例值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;OnActiveSec&lt;/td&gt;
&lt;td&gt;30s&lt;/td&gt;
&lt;td&gt;相对于该单元自身被启动的时间点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;OnBootSec&lt;/td&gt;
&lt;td&gt;15m&lt;/td&gt;
&lt;td&gt;相对于机器被启动的时间点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;OnStartupSec&lt;/td&gt;
&lt;td&gt;2h&lt;/td&gt;
&lt;td&gt;相对于systemd被首次启动的时间点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;OnUnitActiveSec&lt;/td&gt;
&lt;td&gt;1w&lt;/td&gt;
&lt;td&gt;相对于匹配单元最后一次被启动的时间点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;OnUnitInactiveSec&lt;/td&gt;
&lt;td&gt;2d&lt;/td&gt;
&lt;td&gt;相对于匹配单元最后一次被停止的时间点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;OnCalendar&lt;/td&gt;
&lt;td&gt;Mon,Tue &lt;em&gt;-&lt;/em&gt;-01..04 12:00:00&lt;/td&gt;
&lt;td&gt;日历定时事件表达式&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AccuracySec&lt;/td&gt;
&lt;td&gt;5m&lt;/td&gt;
&lt;td&gt;设置定时器的触发精度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RandomizedDelaySec&lt;/td&gt;
&lt;td&gt;10m&lt;/td&gt;
&lt;td&gt;将此单元的定时器随机延迟一小段时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Unit&lt;/td&gt;
&lt;td&gt;foo.service&lt;/td&gt;
&lt;td&gt;该定时器启动的单元(默认是与timer同名的service)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Persistent&lt;/td&gt;
&lt;td&gt;yes, no&lt;/td&gt;
&lt;td&gt;上次触发时间是否永久保存在磁盘上(仅适用于OnCalendar定义的日历定时器)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;WakeSystem&lt;/td&gt;
&lt;td&gt;yes, no&lt;/td&gt;
&lt;td&gt;是否唤醒正在休眠的系统并阻止系统进入休眠状态&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RemainAfterElapse&lt;/td&gt;
&lt;td&gt;yes, no&lt;/td&gt;
&lt;td&gt;是否保持已过期定时器单元的已加载(loaded)状态&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;关于systemd中service，请参见前面文章《使用Systemd管理应用》&lt;/p&gt;

&lt;p&gt;Systemd Timer &lt;a href=&#34;https://gist.github.com/xionglun/8f785fd2a2c8295e996767de5daecaf8&#34;&gt;示例&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;资料引用&#34;&gt;资料引用&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://weiya.me/item/54.html&#34;&gt;Ubuntu下利用Crontab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Systemd/Timers&#34;&gt;Sytemd Timer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.ubuntu.com/community/CronHowto&#34;&gt;CronHowto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wephi.jzland.com/doku.php?id=os:linux:systemd_timer&#34;&gt;使用systemd执行定时任务&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>使用rsyslog集中管理日志</title>
      <link>http://dmdgeeker.com/2017/02/10/%E4%BD%BF%E7%94%A8rsyslog%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86%E6%97%A5%E5%BF%97/</link>
      <pubDate>Fri, 10 Feb 2017 17:06:40 +0800</pubDate>
      <author>xheavey@gmail.com (Allen Heavey)</author>
      <guid>http://dmdgeeker.com/2017/02/10/%E4%BD%BF%E7%94%A8rsyslog%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86%E6%97%A5%E5%BF%97/</guid>
      <description>

&lt;h3 id=&#34;关于syslog&#34;&gt;关于syslog&lt;/h3&gt;

&lt;p&gt;Syslog是linux上传统的日志管理工具，而rsyslog是其改进版。很多系统都已将syslog替换为rsyslog进行日志管理了。&lt;/p&gt;

&lt;h3 id=&#34;syslog相关知识&#34;&gt;Syslog相关知识&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Facility设施&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;代码&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;kern&lt;/td&gt;
&lt;td&gt;内核&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;user&lt;/td&gt;
&lt;td&gt;用户级&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;mail&lt;/td&gt;
&lt;td&gt;邮件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;daemon&lt;/td&gt;
&lt;td&gt;系统&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;auth&lt;/td&gt;
&lt;td&gt;安全与授权&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;syslog&lt;/td&gt;
&lt;td&gt;守护进程&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;lpr&lt;/td&gt;
&lt;td&gt;打印相关&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;news&lt;/td&gt;
&lt;td&gt;网络消息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;uucp&lt;/td&gt;
&lt;td&gt;uucp子系统&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;时钟&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;authpriv&lt;/td&gt;
&lt;td&gt;安全与授权&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;ftp&lt;/td&gt;
&lt;td&gt;FTP&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;NTP&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;日志审计&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;日志报警&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;cron&lt;/td&gt;
&lt;td&gt;定时器&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;local0&lt;/td&gt;
&lt;td&gt;用户自定义&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;local1&lt;/td&gt;
&lt;td&gt;用户自定义&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;local2&lt;/td&gt;
&lt;td&gt;用户自定义&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;local3&lt;/td&gt;
&lt;td&gt;用户自定义&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;local4&lt;/td&gt;
&lt;td&gt;用户自定义&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;local5&lt;/td&gt;
&lt;td&gt;用户自定义&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;local6&lt;/td&gt;
&lt;td&gt;用户自定义&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;local7&lt;/td&gt;
&lt;td&gt;用户自定义&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;Level级别(重要性从高到低)&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;代码&lt;/th&gt;
&lt;th&gt;级别&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;Emergency&lt;/td&gt;
&lt;td&gt;emerg&lt;/td&gt;
&lt;td&gt;紧急&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Alert&lt;/td&gt;
&lt;td&gt;alert&lt;/td&gt;
&lt;td&gt;报警&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Critical&lt;/td&gt;
&lt;td&gt;crit&lt;/td&gt;
&lt;td&gt;关键&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;td&gt;err&lt;/td&gt;
&lt;td&gt;错误&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Warning&lt;/td&gt;
&lt;td&gt;warn&lt;/td&gt;
&lt;td&gt;警告&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;Notice&lt;/td&gt;
&lt;td&gt;notice&lt;/td&gt;
&lt;td&gt;通知&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;Informational&lt;/td&gt;
&lt;td&gt;info&lt;/td&gt;
&lt;td&gt;消息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;Debug&lt;/td&gt;
&lt;td&gt;debug&lt;/td&gt;
&lt;td&gt;调试&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;使用rsyslog记录日志&#34;&gt;使用rsyslog记录日志&lt;/h3&gt;

&lt;p&gt;当前很多应用都已支持syslog进行日志记录&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;docker&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run --log-driver=syslog --log-opt syslog-facility=local0 --log-opt tag=logTag
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;systemd&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# example.service
[service]
StandardOutput=syslog
StandardError=syslog
SyslogIdentifier=example
SyslogFacility=local0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;启动一个rsyslog服务端&#34;&gt;启动一个rsyslog服务端&lt;/h3&gt;

&lt;p&gt;一般linux服务器上已包含的rsyslog包都具有服务功能，但是默认没有启用。&lt;br /&gt;
如果要启用日志服务器功能，则需要修改&lt;code&gt;/etc/rsyslog.conf&lt;/code&gt;这个文件。&lt;/p&gt;

&lt;p&gt;更改如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# provides UDP syslog reception
#module(load=&amp;quot;imudp&amp;quot;)
#input(type=&amp;quot;imudp&amp;quot; port=&amp;quot;514&amp;quot;)
# 取消上面两行的注释，如下所示，即可开启UDP端口514进行日志收集
module(load=&amp;quot;imudp&amp;quot;)
input(type=&amp;quot;imudp&amp;quot; port=&amp;quot;514&amp;quot;)

# provides TCP syslog reception
#module(load=&amp;quot;imtcp&amp;quot;)
#input(type=&amp;quot;imtcp&amp;quot; port=&amp;quot;514&amp;quot;)
# 取消上面两行的注释，如下所示，即可开启TCP端口514进行日志收集
module(load=&amp;quot;imtcp&amp;quot;)
input(type=&amp;quot;imtcp&amp;quot; port=&amp;quot;514&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果只需要UDP或者TCP方式，只需要取消注释对应的两行即可。&lt;/p&gt;

&lt;h3 id=&#34;客户端日志发送到远程服务端&#34;&gt;客户端日志发送到远程服务端&lt;/h3&gt;

&lt;p&gt;假如需要将A服务器上日志发送到B服务器，需要B服务器上rsyslog接收日志功能&lt;a href=&#34;#启动一个rsyslog服务器&#34;&gt;开启&lt;/a&gt;。&lt;br /&gt;
同时，修改A服务器上&lt;code&gt;/etc/rsyslog.conf&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;更改示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 正常日志保存如下所示
# [facility].[level] [destination]
# 示例: mail.warn   /var/log/mail.warn

# 三种发送方式
# UDP      前缀为@             @192.168.1.2:514
# TCP      前缀为@@            @@192.168.1.2:514
# RELP     前缀为:omrelp:      :omrelp:192.168.1.2:514

# 将local0的所有日志以UDP都发送到192.168.1.2这如机器上(默认端口号是514)
local0.* @192.168.1.2
# 将user类应用产生的info级别日志以TCP方式发送到192.168.1.2这台机器上，端口号是514
user.info @@192.168.1.2:514

# 通过syslog的tag进行区分，将以myapp-为前缀的日志发送到远程服务器上
:syslogtag, startswith, &amp;quot;myapp-&amp;quot;  @@192.168.1.2
# 通过消息内容过滤，包含sns_log的发送到远程服务器上
:rawmsg, contains, &amp;quot;sns_log&amp;quot;    @@192.168.1.2
# 丢弃含有sns_debug的消息
:rawmsg, contains, &amp;quot;sns_debug&amp;quot;  ~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意此文件是顺序相关的。&lt;/p&gt;

&lt;p&gt;此处的&lt;code&gt;rawmsg&lt;/code&gt;是消息字段，详见&lt;a href=&#34;http://www.rsyslog.com/doc/master/configuration/properties.html&#34;&gt;rsyslog消息字段&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;除了&lt;code&gt;startswith&lt;/code&gt;与&lt;code&gt;contains&lt;/code&gt;外，还有其它比较关键词：&lt;code&gt;isequal&lt;/code&gt;, &lt;code&gt;regex&lt;/code&gt;, &lt;code&gt;contains_i&lt;/code&gt;, &lt;code&gt;ereregex&lt;/code&gt;, &lt;code&gt;isempty&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;服务端接收远程日志&#34;&gt;服务端接收远程日志&lt;/h3&gt;

&lt;p&gt;服务端也需要对&lt;code&gt;/etc/rsyslog.conf&lt;/code&gt;进行相应修改，以接收远程日志。&lt;/p&gt;

&lt;p&gt;更改示例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 定义一个名为customformat模板, 为信息加上日志时间
$template customformat, &amp;quot;%TIMESTAMP:::date-mysql% %FROMHOST-IP%%msg%n&amp;quot;
# 定义日志文件的名称，按照年月日
$template DynFile,   &amp;quot;/var/log/%$programname%%$year%%$month%%$day%.log&amp;quot;
# 把rawmsg(也可以使用msg)日志中包含sns_log标志的信息写到DynFile定义的日志文件里
:rawmsg, contains, &amp;quot;sns_log&amp;quot;    ?DynFile;customformat
# 这个表示丢弃包含sns_debug标志的信息, 一般都加上它, 以免多个日志文件记录重复的日志
:rawmsg, contains, &amp;quot;sns_debug&amp;quot;  ~
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;将非syslog日志转发到远程服务端&#34;&gt;将非syslog日志转发到远程服务端&lt;/h3&gt;

&lt;p&gt;这里假设有一个&lt;code&gt;helloworld&lt;/code&gt;的应用，产生的日志记录到了&lt;code&gt;/var/log/helloworld.log&lt;/code&gt;这个文件中。&lt;/p&gt;

&lt;p&gt;首先，在应用所有机器上，修改&lt;code&gt;/etc/rsyslog.conf&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 加载imfile这个模块
module(load=&amp;quot;imfile&amp;quot; PollingInterval=&amp;quot;5&amp;quot;)
# 指定日志文件路径以及tag, severity, facility这些参数
input(type=&amp;quot;imfile&amp;quot; File=&amp;quot;/var/log/helloworld.log&amp;quot; Tag=&amp;quot;helloworld&amp;quot; Severity=&amp;quot;error&amp;quot; Facility=&amp;quot;local0&amp;quot;)
# 将helloworld的应用日志发送到远程服务器
:programname, contains, &amp;quot;helloworld&amp;quot; @192.168.1.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nginx日志发送到rsyslog&#34;&gt;Nginx日志发送到rsyslog&lt;/h3&gt;

&lt;p&gt;Nginx(1.7.1+)可以直接发送日志到rsyslog，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# nginx.conf
# server {
error_log syslog:server=192.168.1.1 debug;  # 将debug类型日志发送到192.168.1.1这台机器上
access_log syslog:server=[2001:db8::1]:12345,facility=local7,tag=nginx,severity=info combined;
# }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;相关资料&#34;&gt;相关资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Syslog&#34;&gt;Wiki syslog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.rsyslog.com/doc/master/configuration/properties.html&#34;&gt;rsyslog消息字段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/admin/logging/overview/#/syslog&#34;&gt;Docker syslog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.rsyslog.com/how-to-bind-a-template/&#34;&gt;rsyslog如何绑定模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://indevwith.streamroot.io/centralized-logs-with-rsyslog-systemd-and-golang/&#34;&gt;Golang集中式日志管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mos.meituan.com/library/5/how-to-config-rsyslog/&#34;&gt;rsyslog配置简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/s1-basic_configuration_of_rsyslog.html&#34;&gt;Redhat rsyslog基本配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://xstarcd.github.io/wiki/Linux/rsyslog_logrotate.html&#34;&gt;rsyslogd服务器及负载均衡&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MySQL 基本操作</title>
      <link>http://dmdgeeker.com/2017/01/01/mysql-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 01 Jan 2017 17:06:40 +0800</pubDate>
      <author>xheavey@gmail.com (Allen Heavey)</author>
      <guid>http://dmdgeeker.com/2017/01/01/mysql-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <description>

&lt;h3 id=&#34;安装使用&#34;&gt;安装使用&lt;/h3&gt;

&lt;h5 id=&#34;安装&#34;&gt;安装&lt;/h5&gt;

&lt;p&gt;Ubuntu 16.04&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install mysql-server
sudo mysql_secure_installation     # 生产环境必备，安装一些安全策略
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;访问mysql&#34;&gt;访问mysql&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  -u  username 登陆数据库所使用的数据库用户
  -p  password 使用密码登陆，如果没指定，则会在下面提示输入
  -D  database 此次登陆默认使用的数据库
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基本操作&#34;&gt;基本操作&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; SHOW DATABASES;                          # 显示所有数据库
mysql&amp;gt; USE DATABASE;                            # 选择某个数据库
mysql&amp;gt; SHOW TABLES;                             # 显示当前数据库的所有表
mysql&amp;gt; SHOW VARIABLES LIKE &#39;%char%&#39;;            # 显示数据库所用字符集
mysql&amp;gt; SHOW FULL COLUMNS FROM database.table;   # 显示某个表的字符集
mysql&amp;gt; DESC TABLENAME;                          # 查看某个表的结构

mysql&amp;gt; SHOW GRANTS;     # 查看当前用户权限
mysql&amp;gt; SHOW GRANTS FRO &#39;username&#39;@&#39;host&#39;;  # 查看某个用户的权限
mysql&amp;gt; CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;  # 创建用户
# host使用%为允许从任意地方登录，如果只允许用户本地登录，改成localhost即可
mysql&amp;gt; GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;;  # 授权给某个用户
# privileges 权限，可选值为：SELECT, UPDATE, INSERT, DELETE, DROP, CREATE, ALL 等。
# databasename 数据库名，对所有数据库给予权限用 * 来表示。
# tablename 表名，对所有的表给予权限用 * 来表示。
# 示例：GRANT ALL ON test.* TO &#39;username&#39;@&#39;%&#39;;
# 用此种方式被授权的用户不能给其他用户授权，如需要被授权用户可以进行授权，则需
# GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39; WITH GRANT OPTION;
mysql&amp;gt; FLUSH PRIVILEGES;            # 应用更改的权限
mysql&amp;gt; REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;  # 撤消用户权限
mysql&amp;gt; DROP USER &#39;username&#39;@&#39;host&#39;;             # 删除用户

# 修改数据库或者表字符集为utf8mb4
mysql&amp;gt; ALTER DATABASE databasename CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
mysql&amp;gt; ALTER TABLE tablename CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

# 重命名数据库
mysql&amp;gt; CREATE DATABASE newdb;  # 首先，新创建一个数据库
mysql&amp;gt; RENAME TABLE old_db.table TO new_db.table;  # 将旧数据库中表重命名到新库中
mysql&amp;gt; ; # 注意调整数据库中权限

$ mysql -u USERNAME -p PASSWORD -D DATABASE &amp;lt; sql_file        # 执行某个sql文件
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;配置相关&#34;&gt;配置相关&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将字符编码设置为UTF-8&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf      # 老版本配置文件: /etc/mysql/my.cnf
# [client]
# default-character-set=utf8mb4
#
# [mysqld]
# character-set-server=utf8mb4
# collation-server=utf8mb4_unicode_ci
# init_connect=&#39;SET NAMES utf8mb4&#39;
# skip-character-set-client-handshake = true
#
# [mysql]
# default-character-set = utf8mb4
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;让MySQL可以被远程访问&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf      # 老版本配置文件: /etc/mysql/my.cnf
# 注释掉:  #bind-address  =  127.0.0.1
# 再重启MySQL服务
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重置MySQL root 密码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 重置密码:
mysqladmin -u root password NEWPASS
# 更改密码:
mysqladmin -u root -p PASSWORD
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看MySQL当前连接数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看当前连接数：
mysql&amp;gt; show status like &#39;Conn%&#39;;
# 查看当前客户端连接：
mysql&amp;gt; show processlist;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;基本使用&#34;&gt;基本使用&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; SELECT * FROM users LIMIT 5, 10; # 从users表中取出第5条开始的10条数据
mysql&amp;gt; SELECT * FROM users LIMIT 10 OFFSET 5; # 从users表中取出第5条开始的10条数据
mysql&amp;gt; SELECT user_id, age, name FROM my_user ORDER BY age DESC, user_id DESC # 多字段排序
# 多字段排序先以第一个字段进行排序，若第一个字段重复，则以第二个字段进行排序
mysql&amp;gt; SELECT * FROM users WHERE email REGEXP &#39;^.*@qq\\.com$&#39;; # 取出所有使用QQ邮箱的用户
mysql&amp;gt; SELECT concat(first_name, last_name) AS name FROM users;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;问题与解决办法&#34;&gt;问题与解决办法&lt;/h2&gt;

&lt;h4 id=&#34;1-mysql-在导入大量数据时缓慢的问题&#34;&gt;1) MySQL 在导入大量数据时缓慢的问题&lt;/h4&gt;

&lt;p&gt;MySQL导出的SQL语句在导入时有可能会非常非常慢，经历过导入仅45万条记录，竟用了近3个小时。在导出时合理使用几个参数，可以大大加快导 入的速度。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-e&lt;/td&gt;
&lt;td&gt;使用包括几个VALUES列表的多行INSERT语法;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;ndash;max_allowed_packet=XXX&lt;/td&gt;
&lt;td&gt;客户端/服务器之间通信的缓存区的最大大小;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;ndash;net_buffer_length=XXX&lt;/td&gt;
&lt;td&gt;TCP/IP和套接字通信缓冲区大小,创建长度达net_buffer_length的行。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;注意：max_allowed_packet和net_buffer_length不能比目标数据库的设定数值大，否则可能出错。&lt;/p&gt;

&lt;p&gt;首先确定目标库的参数值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; show variables like &#39;max_allowed_packet&#39;;
mysql&amp;gt; show variables like &#39;net_buffer_length&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据参数值书写mysqldump命令从源数据库导出数据，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysqldump -u root -p -e --max_allowed_packet=1048576 --net_buffer_length=16384 db1 &amp;gt; backup.sql
# 使用-B(--databases)选项备份多个数据库
mysqldump -uroot -p -B db1 db2 db3 &amp;gt; db.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后可以直接进行导入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql -u root -p &amp;lt; ./backup.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-mysql-中文匹配&#34;&gt;2) MySQL 中文匹配&lt;/h4&gt;

&lt;p&gt;使用LIKE时，中文匹配的问题&lt;/p&gt;

&lt;h3 id=&#34;相关资料&#34;&gt;相关资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mysql.taobao.org/monthly/2015/10/01/&#34;&gt;MySQL InnoDB 全文索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.itdadao.com/articles/c15a643840p0.html&#34;&gt;MySQL 5.7 InnoDB全文索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/67093/how-do-i-quickly-rename-a-mysql-database-change-schema-name&#34;&gt;MySQL 数据库重命名数据库&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>使用Systemd管理应用</title>
      <link>http://dmdgeeker.com/2016/11/08/%E4%BD%BF%E7%94%A8systemd%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8/</link>
      <pubDate>Tue, 08 Nov 2016 17:06:40 +0800</pubDate>
      <author>xheavey@gmail.com (Allen Heavey)</author>
      <guid>http://dmdgeeker.com/2016/11/08/%E4%BD%BF%E7%94%A8systemd%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8/</guid>
      <description>

&lt;h3 id=&#34;关于systemd&#34;&gt;关于systemd&lt;/h3&gt;

&lt;p&gt;Systemd在新版Linux操作系统(Ubuntu 15.04+, RHEL 7+, Debian 8+)里基本都已成为内置软件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl --version   # 查看systemd版本号
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unit&#34;&gt;Unit&lt;/h3&gt;

&lt;p&gt;Systemd以&lt;code&gt;Unit&lt;/code&gt;作为基本管理单元，一般存放于&lt;code&gt;/usr/lib/systemd/system/&lt;/code&gt;或&lt;code&gt;/lib/systemd/system&lt;/code&gt;和&lt;code&gt;/etc/systemd/system/&lt;/code&gt;目录(后者优先级更高)。&lt;/p&gt;

&lt;p&gt;其支持类型有：SERVICE.service, SOCKET.socket, DEVICE.device, MOUNT.mount, AUTOMOUNT.automount, SWAP.swap, TARGET.target, PATH.path, TIMER.timer, SLICE.slice, SCOPE.scope&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl list-unit-files            # 查看所有已安装服务
systemctl list-units --type=service  # 列出所有正在运行的、类型为 service 的 Unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;管理自定义的应用一般只需要用到&lt;strong&gt;SERVICE.service&lt;/strong&gt;配置文件。&lt;/p&gt;

&lt;h3 id=&#34;服务配置文件&#34;&gt;服务配置文件&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;此处使用了一个简单的shell脚本，位于/usr/local/bin/hello
其内容为：&lt;/p&gt;

&lt;p&gt;#!/bin/sh&lt;br /&gt;
  echo &amp;ldquo;This is hello program!&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;服务的配置文件一般格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Unit]
# 应用描述
Description=A test program
# 应用文档地址
Documentation=https://docs.example.com
# 必须在某一个或多个单元之后启动
After=network.target ssh.service
# 依赖于某一个或多个单元
Requires=ssh.service

[Service]
# 进程启动方式，有：simple(默认), forking, oneshot, notify, dbus, idle这几种方式
Type=simple
# 启动服务之前执行的命令
ExecStartPre=/usr/bin/which hello
# 启动程序
ExecStart=/user/local/bin/hello
# 启动服务之后执行的命令
ExecStartPost=/bin/echo &amp;quot;start hello success.&amp;quot;
# 停止服务时执行的命令
ExecStop=/bin/echo &amp;quot;stop hello&amp;quot;
# 重启服务时执行的命令
ExecReload=/bin/kill -s HUP $MAINPID
# 进程结束后重启方式，可选值有：always, on-success, on-failure, on-abnormal, on-abort, on-watchdog
Restart=on-failure
# 重启间隔秒数
RestartSec=30
# 标准输出到
StandardOutput=syslog
# 标准错误输出到
StandardError=syslog
# 设置syslog中log的程序名称
SyslogIdentifier=helloexample
# 设置syslog中log类型
SyslogFacility=local0
# 设置syslog中log级别，此处为info
SyslogLevel=info
# 程序运行时的用户
User=root
# 程序运行时分配的组
Group=root
# 程序的环境变量
Environment=NODE_ENV=production

# 依赖于
[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将上面配置写入到&lt;code&gt;/etc/systemd/system/hello.service&lt;/code&gt;中，然后执行命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl daemon-reload
systemctl enable hello.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样即可加载服务到systemd中。&lt;/p&gt;

&lt;p&gt;检查服务是否已加入到systemd管理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl status hello.service
#● hello.service - A test program
#   Loaded: loaded (/lib/systemd/system/hello.service; enabled; vendor preset: enabled)
#   Active: inactive (dead)
#     Docs: https://docs.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl start hello.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看hello服务输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;journalctl -u hello.service
# 1) 没有使用SyslogIdentifier时的输出
#Feb 07 14:19:40 i-rcaex55q systemd[1]: Starting A test program...
#Feb 07 14:19:40 i-rcaex55q which[27364]: /usr/local/bin/hello
#Feb 07 14:19:40 i-rcaex55q echo[27369]: start hello success.
#Feb 07 14:19:40 i-rcaex55q systemd[1]: Started A test program.
#Feb 07 14:19:40 i-rcaex55q hello[27368]: This is hello program!
#Feb 07 14:19:40 i-rcaex55q echo[27372]: stop hello
#Feb 07 14:22:30 i-rcaex55q systemd[1]: Stopped A test program.
# 2) 使用了SyslogIdentifier=helloexample时的输出
#Feb 07 14:22:39 i-rcaex55q systemd[1]: Starting A test program...
#Feb 07 14:22:39 i-rcaex55q helloexample[27419]: /usr/local/bin/hello
#Feb 07 14:22:39 i-rcaex55q helloexample[27423]: start hello success.
#Feb 07 14:22:39 i-rcaex55q helloexample[27422]: This is hello program!
#Feb 07 14:22:39 i-rcaex55q helloexample[27425]: stop hello
#Feb 07 14:22:39 i-rcaex55q systemd[1]: Started A test program.
#Feb 07 14:30:16 i-rcaex55q systemd[1]: Stopped A test program.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.codeship.com/running-node-js-linux-systemd/&#34;&gt;Running node.js with systemd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.digitalocean.com/community/tutorials/how-to-deploy-node-js-applications-using-systemd-and-nginx&#34;&gt;Node.js systemd &amp;amp; nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html&#34;&gt;Systemd 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Systemd&#34;&gt;Archlinux Systemd介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Gitlab安装</title>
      <link>http://dmdgeeker.com/2016/10/08/gitlab%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 08 Oct 2016 12:00:00 +0800</pubDate>
      <author>xheavey@gmail.com (Allen Heavey)</author>
      <guid>http://dmdgeeker.com/2016/10/08/gitlab%E5%AE%89%E8%A3%85/</guid>
      <description>

&lt;h3 id=&#34;安装环境配置&#34;&gt;安装环境配置&lt;/h3&gt;

&lt;p&gt;环境配置参见&lt;a href=&#34;https://github.com/gitlabhq/gitlabhq#software-stack&#34;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ubuntu/Debian/CentOS/RHEL&lt;/li&gt;
&lt;li&gt;Ruby (MRI) 2.3&lt;/li&gt;
&lt;li&gt;Git 2.7.4+&lt;/li&gt;
&lt;li&gt;Redis 2.8+&lt;/li&gt;
&lt;li&gt;MySQL or PostgreSQL&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;安装步骤&#34;&gt;安装步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装相关依赖&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install curl openssh-server ca-certificates
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加&lt;code&gt;gitlab-ce&lt;/code&gt;到apt仓库中并安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash
sudo apt-get install gitlab-ce
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置并启动Gitlab，配置文件位于(&lt;code&gt;/etc/gitlab/gitlab.rb&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gitlab-ctl reconfigure
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;安装详解&#34;&gt;安装详解&lt;/h4&gt;

&lt;p&gt;在上面的安装步骤中，它自动化的安装了&lt;code&gt;PostgreSQL&lt;/code&gt;, &lt;code&gt;Nginx&lt;/code&gt;等软件。&lt;/p&gt;

&lt;h3 id=&#34;配置相关&#34;&gt;配置相关&lt;/h3&gt;

&lt;p&gt;配置文件位于&lt;code&gt;/etc/gitlab/gitlab.rb&lt;/code&gt;中，所有配置都在些进行修改，然后执行&lt;code&gt;reconfigure&lt;/code&gt;命名即可生效。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;邮件SMTP配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# gitlab_rails[&#39;smtp_enable&#39;] = true
# gitlab_rails[&#39;smtp_address&#39;] = &amp;quot;smtp.server&amp;quot;
# gitlab_rails[&#39;smtp_port&#39;] = 465
# gitlab_rails[&#39;smtp_user_name&#39;] = &amp;quot;smtp user&amp;quot;
# gitlab_rails[&#39;smtp_password&#39;] = &amp;quot;smtp password&amp;quot;
# gitlab_rails[&#39;smtp_domain&#39;] = &amp;quot;example.com&amp;quot;
# gitlab_rails[&#39;smtp_authentication&#39;] = &amp;quot;login&amp;quot;
# gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true
# gitlab_rails[&#39;smtp_tls&#39;] = false
# gitlab_rails[&#39;smtp_openssl_verify_mode&#39;] = &#39;none&#39; # Can be: &#39;none&#39;, &#39;peer&#39;, &#39;client_once&#39;, &#39;fail_if_no_peer_cert&#39;, see http://api.rubyonrails.org/classes/ActionMailer/Base.html
# gitlab_rails[&#39;smtp_ca_path&#39;] = &amp;quot;/etc/ssl/certs&amp;quot;
# gitlab_rails[&#39;smtp_ca_file&#39;] = &amp;quot;/etc/ssl/certs/ca-certificates.crt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将上面的注释符号&lt;code&gt;#&lt;/code&gt;去掉，并填写相应的值即可。参见&lt;a href=&#34;https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/smtp.md&#34;&gt;SMTP配置&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;认证LDAP配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;gitlab_rails[&#39;ldap_enabled&#39;] = true
gitlab_rails[&#39;ldap_servers&#39;] = YAML.load &amp;lt;&amp;lt;-&#39;EOS&#39; # remember to close this block with &#39;EOS&#39; below
main: # &#39;main&#39; is the GitLab &#39;provider ID&#39; of this LDAP server
label: &#39;Authenticate&#39;
host: &#39;ldap.example.com&#39;
port: 389
uid: &#39;uid&#39;
method: &#39;plain&#39; # &amp;quot;tls&amp;quot; or &amp;quot;ssl&amp;quot; or &amp;quot;plain&amp;quot;
bind_dn: &#39;uid=root,dc=example,dc=com&#39;
password: &#39;123456789&#39;
active_directory: false
allow_username_or_email_login: false
block_auto_created_users: false
base: &#39;&#39;
user_filter: &#39;&#39;
attributes:
  username: [&#39;uid&#39;, &#39;username&#39;, &#39;sAMAccountName&#39;]
  email:    [&#39;mail&#39;, &#39;email&#39;, &#39;userPrincipalName&#39;]
  name:       &#39;displayName&#39;
  first_name: &#39;cn&#39;
  last_name:  &#39;sn&#39;
EOS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照上面的配置，进行相应的修改即可。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据库配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# gitlab_rails[&#39;db_adapter&#39;] = &amp;quot;postgresql&amp;quot;
# gitlab_rails[&#39;db_encoding&#39;] = &amp;quot;unicode&amp;quot;
# gitlab_rails[&#39;db_collation&#39;] = nil
# gitlab_rails[&#39;db_database&#39;] = &amp;quot;gitlabhq_production&amp;quot;
# gitlab_rails[&#39;db_pool&#39;] = 10
# gitlab_rails[&#39;db_username&#39;] = &amp;quot;gitlab&amp;quot;
# gitlab_rails[&#39;db_password&#39;] = nil
# gitlab_rails[&#39;db_host&#39;] = nil
# gitlab_rails[&#39;db_port&#39;] = 5432
# gitlab_rails[&#39;db_socket&#39;] = nil
# gitlab_rails[&#39;db_sslmode&#39;] = nil
# gitlab_rails[&#39;db_sslrootcert&#39;] = nil
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Redis配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;## Redis TCP connection
# gitlab_rails[&#39;redis_host&#39;] = &amp;quot;127.0.0.1&amp;quot;
# gitlab_rails[&#39;redis_port&#39;] = 6379
# gitlab_rails[&#39;redis_password&#39;] = nil
# gitlab_rails[&#39;redis_database&#39;] = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多配置请查看&lt;code&gt;/etc/gitlab/gitlab.rb&lt;/code&gt;这个文件。&lt;/p&gt;

&lt;h2 id=&#34;使用docker进行gitlab安装&#34;&gt;使用docker进行Gitlab安装&lt;/h2&gt;

&lt;p&gt;待续&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gitlab.com/gitlab-org/omnibus-gitlab/tree/master/doc/settings&#34;&gt;Gitlab配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/&#34;&gt;Gitlab清华大学镜像站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://about.gitlab.com/downloads/#ubuntu1604&#34;&gt;Gitlab下载安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/administration/auth/ldap.html&#34;&gt;Gitlab LDAP配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>